# 抖音媒体提取器 & 用户主页提取器 - 技术原理

本文档详细介绍了 `douyin_phaser.py` (媒体提取器) 和 `douyin_user_phaser.py` (用户主页提取器) 的内部工作原理。

## 技术架构

```
┌─────────────────────────────────────────────────────────────┐
│                    用户输入: 抖音视频页面 URL                  │
10: └─────────────────────────────────────────────────────────────┘
                               │
                               ▼
┌─────────────────────────────────────────────────────────────┐
│                  Playwright 启动 Chromium 浏览器              │
│                    (模拟真实用户访问)                          │
└─────────────────────────────────────────────────────────────┘
                               │
                               ▼
┌─────────────────────────────────────────────────────────────┐
│                    注册网络响应监听器                          │
│              page.on("response", handle_response)            │
└─────────────────────────────────────────────────────────────┘
                               │
                               ▼
┌─────────────────────────────────────────────────────────────┐
│                      导航到目标视频页面                        │
└─────────────────────────────────────────────────────────────┘
                               │
                               ▼
┌─────────────────────────────────────────────────────────────┐
│       拦截 API 响应: aweme/v1/web/aweme/detail               │
│              (包含视频详情的 JSON 数据)                        │
└─────────────────────────────────────────────────────────────┘
                               │
                               ▼
┌─────────────────────────────────────────────────────────────┐
│                 解析 bit_rate 数组                            │
│           (包含所有清晰度的视频流信息)                          │
└─────────────────────────────────────────────────────────────┘
                               │
                               ▼
┌─────────────────────────────────────────────────────────────┐
│              选择最高画质的 mp4 格式视频链接                    │
└─────────────────────────────────────────────────────────────┘
                               │
                               ▼
┌─────────────────────────────────────────────────────────────┐
│                       输出视频直链                            │
└─────────────────────────────────────────────────────────────┘
```

## 1. 媒体提取器原理 (douyin_phaser.py)

### 1.1 为什么使用浏览器自动化？

抖音网页端有多层反爬虫保护：

| 保护机制 | 说明 |
|---------|------|
| **动态签名** | 每个 API 请求需要 `__ac_signature`、`X-Bogus` 等动态生成的签名参数 |
| **JavaScript 混淆** | 签名算法被混淆在 `_$jsvmprt` 等 JS 虚拟机中 |
| **客户端验证** | 首次访问会加载验证脚本，检测是否为真实浏览器 |
| **Cookie 依赖** | 需要有效的会话 Cookie 才能获取完整数据 |

**解决方案**：使用 Playwright 控制真实浏览器，让浏览器自动处理所有 JavaScript 执行和签名生成。

### 1.2 网络请求拦截机制 (Video)

```python
def handle_response(response):
    # 监听所有网络响应
    if "aweme/v1/web/aweme/detail" in response.url and response.status == 200:
        # 这是视频详情 API，包含所有清晰度信息
        json_data = response.json()
        # 解析视频数据...

# 注册监听器
page.on("response", handle_response)
```

当浏览器加载抖音视频页面时，页面会自动发起 API 请求获取视频详情。我们拦截这个响应，就能获取到所有视频信息。

### 1.3 清晰度选择算法

API 返回的 `bit_rate` 数组包含所有可用清晰度。

**选择策略**：
1. **只选 `mp4` 格式** - `dash` 格式是视频/音频分离流，方便直接播放/下载
2. **优先最高分辨率** - 4K > 2K > 1080p > 720p
3. **同分辨率选最高码率** - 码率越高，画质越好

### 1.4 图文/动图提取原理 (Note)

图集/动图页面 (`/note/`) 的数据提取采用了混合策略：

1. **API 提取 (优先)**: 尝试调用 `aweme/v1/web/aweme/detail` API。这是获取动图（虽然不仅是 WebP 格式，但本质上是视频）和原始高清图片的最佳方式。
2. **DOM 解析 (降级)**: 如果 API 调用失败，脚本会回退到解析页面 DOM，从 `background-image` 样式或 `<img>` 标签中提取图片链接。

对于动图内容，抖音实际上同时提供了 **WebP 动图** 和 **MP4 视频** 两种格式。我们的 API 会同时返回这两种链接，供调用方选择。

---

## 2. 用户主页提取器原理 (douyin_user_phaser.py)

用户主页提取器需要解决的核心问题是**分页加载**和**签名验证**。

### 2.1 浏览器环境注入 (Browser Context Injection)

与简单的爬虫不同，我们不手动计算 `X-Bogus` 和 `_signature`。相反，我们利用浏览器已经加载好的 JS 环境来帮我们要数据。

**核心逻辑：**
1. 启动 Playwright 浏览器，加载用户主页。
2. 等待页面加载完成，确保抖音的签名 JS (`securitySDK`) 已经初始化。
3. **在浏览器控制台** (Page Context) 中执行 JS 代码，发起 XHR 请求。

这样做的好处是：**所有由页面发出的 XHR 请求，会被抖音的 JS 拦截器自动签名**。我们无需逆向签名算法，直接就能拿到签名后的合法请求。

### 2.2 XHR 注入与分页算法

我们在 Python 中控制分页逻辑，但实际的数据获取是在浏览器页面的 JS 环境中执行的：

**核心参数：**
*   `max_cursor`: 分页游标，通常是时间戳（毫秒）。第一页传 `0`，后续传上一页返回的 `max_cursor`。
*   `count`: 每页数量（默认 18）。
*   `has_more`: 布尔值，标识是否还有更多数据。

**分页流程：**
1.  初始化 `max_cursor = 0`。
2.  进入循环 `while has_more`：
    *   构造 API 请求 URL，带上当前的 `max_cursor`。
    *   在浏览器内执行 JS 代码发起请求（自动附带签名）。
    *   解析返回数据：
        *   获取 `aweme_list` (作品列表)。
        *   更新 `max_cursor` (用于下一页)。
        *   更新 `has_more` 状态。
3.  如果 `has_more` 为 `false` 或 `aweme_list` 为空，结束循环。

这种**在浏览器内执行 XHR** 的方式，避免了复杂的签名逆向工程，同时模拟了真实用户的浏览行为（虽然没有实际滚动页面，但请求逻辑一致）。

### 2.3 身份验证与 Cookie 持久化

为了获取完整的作品列表（避免未登录只能看部分作品），我们实现了 **HttpOnly Cookie** 的导出与复用。

1. **交互式登录 (`--login`)**: 
   启动一个**有头**浏览器，让用户扫码。登录成功后，使用 `context.cookies()` 导出所有 Cookie（包括前端无法读取的 HttpOnly Cookie，如 `sessionid`）。
   
2. **Cookie 注入**:
   在后续的无头浏览器运行中，我们通过 `context.add_cookies(cookies)` 将保存的 JSON Cookie 注入到浏览器环境。这使得无头浏览器拥有了与扫码登录时完全一致的身份状态。

### 2.4 性能优化

- **资源屏蔽**: 屏蔽了图片、字体、CSS、分析脚本等不必要的资源加载，极大提升了页面加载速度。
- **并发控制**: 虽然分页必须串行（需要上一页的 `max_cursor`），但单个请求响应速度极快（通常 < 500ms），因为我们不需要渲染页面，只是借用 JS 环境发请求。

## 总结

| 组件 | 核心技术 | 优势 |
|------|---------|------|
| **媒体提取器** | 响应拦截 (Response Interception) | 无需签名计算，被动获取数据，极快 |
| **用户提取器** | JS 注入执行 (JS Injection) | 利用浏览器环境自动签名，绕过复杂加密 |
